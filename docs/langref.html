<!DOCTYPE html>

<html>
<head>
    <meta http-equip="Context-Type" context="text/html">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>Alias Language Reference</title>
    <style>
      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
    </style>
</head>
<body>
<header><h1>Alias Language Reference</h1></header>
<div id="navigation"><nav>
<h2>Table of Contents</h2>
<ul><li><a href="#1">Block expressions</a>
<ul>
<li><a href="#1.1">Break with expression</a></li>
<li><a href="#1.2">Break to label</a></li>
<li><a href="#1.3">Break void</a></li>
</ul></li>
<li><a href="#2">Control flow</a>
<ul>
<li><a href="#2.1">If statement</a></li>
<li><a href="#2.2">While statement</a></li>
</ul></li>
<li><a href="#3">Definitions</a>
<ul>
<li><a href="#3.1">Definition</a></li>
<li><a href="#3.2">Types</a></li>
<li><a href="#3.3">Type size</a></li>
</ul></li>
<li><a href="#4">Functions</a>
<ul>
<li><a href="#4.1">Functions introduction</a></li>
</ul></li>
<li><a href="#5">Lambda functions</a>
<ul>
<li><a href="#5.1">Simple lambda functions</a></li>
<li><a href="#5.2">Higher order functions</a></li>
</ul></li>
<li><a href="#6">Structs</a>
<ul>
<li><a href="#6.1">Definition of structs</a></li>
<li><a href="#6.2">Structs layout</a></li>
</ul></li>
<li><a href="#7">Typedef</a>
<ul>
<li><a href="#7.1">Int type</a></li>
<li><a href="#7.2">Function type</a></li>
</ul></li>
</ul></nav></div>
<div id="contents-wrapper"><main id="contents">
<h2 id="1">Block expressions</h2>
<h3 id="1.1">Break with expression</h3>
<p>We can return value from a block using break statement. All break expressions have to have equal types.</p>
<pre><code>test demo_break_with_expression {
    def a := {
        break 4
    }
    return test_equal(a, 4)
}

</code></pre>
<h3 id="1.2">Break to label</h3>
<p>We can return to specific block using a label.</p>
<pre><code>test demo_break_to_label {
    def a := { .foo
        {
            break .foo 5
        }
    }
    return test_equal(a, 5)
}

</code></pre>
<h3 id="1.3">Break void</h3>
<p>The expression `{}` is a block, which returns type `#V`. We can use it to break from blocks, which are used as statements (don't return anything and have type `#V`).</p>
<pre><code>test demo_break_from_block {
    def a := 3
    {
        a := 2
        break {}
        a := 3
    }
    return test_equal(a, 2)
}
</code></pre>
<h2 id="2">Control flow</h2>
<h3 id="2.1">If statement</h3>
<p>The if statement consists of set of blocks and conditions. The last block may be without a condition.</p>
<pre><code>test demo_if_statement {
    def a := 3
    if (a = 2)
        a := 1
    else if (a = 3)
        a := 2
    else
        a := 3
    return test_equal(a, 2)
}

</code></pre>
<h3 id="2.2">While statement</h3>
<p>The while statement consists of block an condition.</p>
<pre><code>test demo_while_statement {
    def i := 0
    def sum := 0
    while (i &lt 10) {
        sum := sum + i
        i := i + 1
    }
    return test_equal(sum, 45)
}
</code></pre>
<h2 id="3">Definitions</h2>
<h3 id="3.1">Definition</h3>
<p>Use `def` to define a local variable. The variable must have an initial value after := operator.</p>
<pre><code>test demo_definition {
    def a := 5 // this is variable `a`, which has type `integer`
    def b := '4' // this is variable `b`, which has type `char`
    return 0 // to succeed, the test has to return zero
}

</code></pre>
<h3 id="3.2">Types</h3>
<p>We can write types of local variables explicitly. The types begin with symbol `#`.</p>
<pre><code>test demo_types {
    def a #I := 5 // `#I` is an `integer` type
    def b #C := '4' // `#C` is a `char` type
    return 0
}

</code></pre>
<h3 id="3.3">Type size</h3>
<p>Operator `^` returns size of the packed type in bytes. However, on stack data occupies more space, as it has to be word-aligned.</p>
<pre><code>test demo_type_size {
    if (^#I = 8) {} else { return 1 } // The size of `#I` is 8 bytes
    if (^#C = 1) {} else { return 1 } // The size of `#C` is 1 byte
    return 0
}
</code></pre>
<h2 id="4">Functions</h2>
<h3 id="4.1">Functions introduction</h3>
<p>We can create and call functions.</p>
<pre><code>func .add_one(x #I) -&gt #I {
    return x + 1
}

test demo_functions {
    return test_equal(add_one(1), 2)
}
</code></pre>
<h2 id="5">Lambda functions</h2>
<h3 id="5.1">Simple lambda functions</h3>
<p>The lambda functions don't require to have name. But we can assign them to variables.</p>
<pre><code>test demo_lambda_functions {
    def f := \(x #I) -&gt #I {
        return x + 1
    }
    return test_equal(f(2), 3)
}

</code></pre>
<h3 id="5.2">Higher order functions</h3>
<p>We can pass lambda functions to function calls.</p>
<pre><code>test demo_higher_order_functions {
    def twice := \(f #F(#I) -&gt #I, x #I) -&gt #I {
        return f(f(x))
    }
    return test_equal(twice(\(x #I) -&gt #I return x * x, 2), 16)
}
</code></pre>
<h2 id="6">Structs</h2>
<h3 id="6.1">Definition of structs</h3>
<p>This way we can declare structs.</p>
<pre><code>typedef Pt := #S{ x: #I, y: #I }

test demo_local_struct {
    def pt1 := .{
        x := 32,
        y := 76
    }
    def pt2 := pt1
    if (pt1&-&gtx = pt2&-&gtx) {} else return 1
    if (pt1&-&gty = pt2&-&gty) {} else return 1
    return 0
}

</code></pre>
<h3 id="6.2">Structs layout</h3>
<p>Structs are packed.</p>
<pre><code>typedef Str := #S{ a: #C, b: #C, c: #I, d: #C, e: #I }

test demo_struct_layout {
    if (^#Str = 19) {} else return 1

    def str1 := .{
        a := 'a',
        b := 'b',
        c := 11,
        d := 'd',
        e := 43
    }

    def str2 := .{
        a := 'A',
        b := 'B',
        c := 111,
        d := 'D',
        e := 143
    }

    str2 := str1
    if (str1&-&gtc = str2&-&gtc) {} else return 1
    if (str1&-&gtd = str2&-&gtd) {} else return 1

    def t1 := .{
        a := 12,
        b := str1,
        c := 'C'
    }

    def t2 := t1
    if (str1&-&gta = str2&-&gta) {} else return 1
    if (str1&-&gtc = str2&-&gtc) {} else return 1

    def s1 := t1&-&gtb
    if (s1&-&gtc = 11) {} else return 1

    def sp := s1&
    def s2 := sp$
    if (s2&-&gtc = 11) {} else return 1

    s2&-&gtc& &lt- 100
    s1& &lt- s2
    if (s1&-&gtc = 100) {} else return 1

    return 0
}
</code></pre>
<h2 id="7">Typedef</h2>
<h3 id="7.1">Int type</h3>
<p>We can give names to types.</p>
<pre><code>typedef T := #I

func .add_one(x #T) -&gt #T {
    return x + 1
}

test demo_typedef_int {
    return test_equal(add_one(1), 2)
}

</code></pre>
<h3 id="7.2">Function type</h3>
<p>The function is also a type.</p>
<pre><code>typedef K := #F(#I) -&gt #I

func .apply(f #K, a #T) -&gt #T {
    return f(a)
}

test demo_typedef_function {
    return test_equal(apply(add_one, 1), 2)
}
</code></pre>
</main></div></body></html>
