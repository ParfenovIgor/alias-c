<!DOCTYPE html>

<html>
<head>
    <meta http-equip="Context-Type" context="text/html">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>Alias Language Reference</title>
    <style>
      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
    </style>
</head>
<body>
<header><h1>Alias Language Reference</h1></header>
<div id="navigation"><nav>
<h2>Table of Contents</h2>
<ul><li><a href="#1">Block Expressions</a>
<ul>
<li><a href="#1.1">Return with expression</a></li>
<li><a href="#1.2">Return to label</a></li>
<li><a href="#1.3">Return void</a></li>
</ul></li>
<li><a href="#2">Definitions</a>
<ul>
<li><a href="#2.1">Definition</a></li>
<li><a href="#2.2">Types</a></li>
<li><a href="#2.3">Type size</a></li>
</ul></li>
<li><a href="#3">Functions</a>
<ul>
<li><a href="#3.1">Functions introduction</a></li>
</ul></li>
<li><a href="#4">If</a>
<ul>
<li><a href="#4.1">If statement</a></li>
<li><a href="#4.2">If expression</a></li>
</ul></li>
<li><a href="#5">Lambda Functions</a>
<ul>
<li><a href="#5.1">Simple lambda functions</a></li>
<li><a href="#5.2">Higher order functions</a></li>
</ul></li>
<li><a href="#6">Structs</a>
<ul>
<li><a href="#6.1">Definition of structs</a></li>
<li><a href="#6.2">Structs layout</a></li>
</ul></li>
<li><a href="#7">Typedef</a>
<ul>
<li><a href="#7.1">Int type</a></li>
<li><a href="#7.2">Function type</a></li>
</ul></li>
<li><a href="#8">While</a>
<ul>
<li><a href="#8.1">While statement</a></li>
<li><a href="#8.2">While expression</a></li>
<li><a href="#8.3">While else block</a></li>
<li><a href="#8.4">While continue statement</a></li>
<li><a href="#8.5">While control with labels</a></li>
</ul></li>
</ul></nav></div>
<div id="contents-wrapper"><main id="contents">
<h2 id="1">Block Expressions</h2>
<h3 id="1.1">Return with expression</h3>
<p>We can return value from a block using `return` statement. All return expressions have to have equal types.</p>
<pre><code>test demo_return_with_expression {
    def a := {
        return 4
    }
    return test_equal(a, 4)
}

</code></pre>
<h3 id="1.2">Return to label</h3>
<p>We can return to specific block using a label.</p>
<pre><code>test demo_return_to_label {
    def a := { .foo
        eval {
            return .foo 5
        }
    }
    return test_equal(a, 5)
}

</code></pre>
<h3 id="1.3">Return void</h3>
<p>The expression `{}` is a block, which returns type `#V`. We can use it to break from blocks, which are used as statements (don't return anything and have type `#V`).</p>
<pre><code>test demo_return_from_block {
    def a := 3
    eval {
        a := 2
        return {}
        a := 3
    }
    return test_equal(a, 2)
}
</code></pre>
<h2 id="2">Definitions</h2>
<h3 id="2.1">Definition</h3>
<p>Use `def` to define a local variable. The variable must have an initial value after := operator.</p>
<pre><code>test demo_definition {
    def a := 5 // this is variable `a`, which has type `integer`
    def b := '4' // this is variable `b`, which has type `char`
    return 0 // to succeed, the test has to return zero
}

</code></pre>
<h3 id="2.2">Types</h3>
<p>We can write types of local variables explicitly. The types begin with symbol `#`.</p>
<pre><code>test demo_types {
    def a #I := 5 // `#I` is an `integer` type
    def b #C := '4' // `#C` is a `char` type
    return 0
}

</code></pre>
<h3 id="2.3">Type size</h3>
<p>Operator `^` returns size of the packed type in bytes. However, on stack data occupies more space, as it has to be word-aligned.</p>
<pre><code>test demo_type_size { .foo
    eval if (^#I = 8) {} else { return .foo 1 } // The size of `#I` is 8 bytes
    eval if (^#C = 1) {} else { return .foo 1 } // The size of `#C` is 1 byte
    return 0
}
</code></pre>
<h2 id="3">Functions</h2>
<h3 id="3.1">Functions introduction</h3>
<p>We can create and call functions.</p>
<pre><code>func .add_one(x #I) -&gt #I {
    return x + 1
}

test demo_functions {
    return test_equal(add_one(1), 2)
}
</code></pre>
<h2 id="4">If</h2>
<h3 id="4.1">If statement</h3>
<p>The `if` statement consists of set of blocks and conditions. The last block may be without a condition.</p>
<pre><code>test demo_if_statement {
    def a := 3
    eval if (a = 2) {
        a := 1
    }
    else if (a = 3) {
        a := 2
    }
    else {
        a := 3
    }
    return test_equal(a, 2)
}

</code></pre>
<h3 id="4.2">If expression</h3>
<p>The `if` can be used as expression. All branches of `if` have to return equal types, and also `if` has to have an `else` block, if it returns not `#V`.</p>
<pre><code>test demo_if_expression {
    def a := 3
    a := if (a = 2)
        1
    else if (a = 3)
        2
    else
        3
    return test_equal(a, 2)
}
</code></pre>
<h2 id="5">Lambda Functions</h2>
<h3 id="5.1">Simple lambda functions</h3>
<p>The lambda functions don't require to have name. But we can assign them to variables.</p>
<pre><code>test demo_lambda_functions {
    def f := \(x #I) -&gt #I {
        return x + 1
    }
    return test_equal(f(2), 3)
}

</code></pre>
<h3 id="5.2">Higher order functions</h3>
<p>We can pass lambda functions to function calls.</p>
<pre><code>test demo_higher_order_functions {
    def twice := \(f #F(#I) -&gt #I, x #I) -&gt #I {
        return f(f(x))
    }
    return test_equal(twice(\(x #I) -&gt #I x * x, 2), 16)
}
</code></pre>
<h2 id="6">Structs</h2>
<h3 id="6.1">Definition of structs</h3>
<p>This way we can declare structs.</p>
<pre><code>typedef Pt := #S{ x: #I, y: #I }

test demo_local_struct { .foo
    def pt1 := .{
        x := 32,
        y := 76
    }
    def pt2 := pt1
    eval if (pt1&-&gtx = pt2&-&gtx) {} else { return .foo 1 }
    eval if (pt1&-&gty = pt2&-&gty) {} else { return .foo 1 }
    return 0
}

</code></pre>
<h3 id="6.2">Structs layout</h3>
<p>Structs are packed.</p>
<pre><code>typedef Str := #S{ a: #C, b: #C, c: #I, d: #C, e: #I }

test demo_struct_layout { .foo
    eval if (^#Str = 19) {} else { return .foo 1 }

    def str1 := .{
        a := 'a',
        b := 'b',
        c := 11,
        d := 'd',
        e := 43
    }

    def str2 := .{
        a := 'A',
        b := 'B',
        c := 111,
        d := 'D',
        e := 143
    }

    str2 := str1
    eval if (str1&-&gtc = str2&-&gtc) {} else { return .foo 1 }
    eval if (str1&-&gtd = str2&-&gtd) {} else { return .foo 1 }

    def t1 := .{
        a := 12,
        b := str1,
        c := 'C'
    }

    def t2 := t1
    eval if (str1&-&gta = str2&-&gta) {} else { return .foo 1 }
    eval if (str1&-&gtc = str2&-&gtc) {} else { return .foo 1 }

    def s1 := t1&-&gtb
    eval if (s1&-&gtc = 11) {} else { return .foo 1 }

    def sp := s1&
    def s2 := sp$
    eval if (s2&-&gtc = 11) {} else { return .foo 1 }

    s2&-&gtc& &lt- 100
    s1& &lt- s2
    eval if (s1&-&gtc = 100) {} else { return .foo 1 }

    return 0
}
</code></pre>
<h2 id="7">Typedef</h2>
<h3 id="7.1">Int type</h3>
<p>We can give names to types.</p>
<pre><code>typedef T := #I

func .add_one(x #T) -&gt #T {
    return x + 1
}

test demo_typedef_int {
    return test_equal(add_one(1), 2)
}

</code></pre>
<h3 id="7.2">Function type</h3>
<p>The function is also a type.</p>
<pre><code>typedef K := #F(#I) -&gt #I

func .apply(f #K, a #T) -&gt #T {
    return f(a)
}

test demo_typedef_function {
    return test_equal(apply(add_one, 1), 2)
}
</code></pre>
<h2 id="8">While</h2>
<h3 id="8.1">While statement</h3>
<p>The while statement consists of block an condition.</p>
<pre><code>test demo_while_statement {
    def i := 0
    def sum := 0
    eval while (i &lt 10) {
        sum := sum + i
        i := i + 1
    }
    return test_equal(sum, 45)
}

</code></pre>
<h3 id="8.2">While expression</h3>
<p>The `while` can be used as expression. All `break` in `while` and an `else` block have to return equal types, and also `while` has to have an `else` block, if it returns not `#V`.</p>
<pre><code>test demo_while_expression {
    def i := 0
    def sum := 0
    def res := while (1) {
        eval if (i = 10) { break sum }
        sum := sum + i
        i := i + 1
    }
    else 0
    return test_equal(res, 45)
}

</code></pre>
<h3 id="8.3">While else block</h3>
<p>The `else` block will be executed, if we exit the loop when checking a condition, which is false.</p>
<pre><code>test demo_while_else_block {
    def i := 0
    def sum := 0
    def res := while (i = 0) {
        eval if (i = 10) { break sum }
        sum := sum + i
        i := i + 1
    }
    else 0
    return test_equal(res, 0)
}

</code></pre>
<h3 id="8.4">While continue statement</h3>
<p>We can jump to the start of the loop using a `continue` statement.</p>
<pre><code>test demo_while_continue_statement {
    def i := 0
    def sum := 0
    def res := while (1) {
        i := i + 1
        eval if (i &lt 5) { continue }
        eval if (i = 10) { break sum }
        sum := sum + i
    }
    else 0
    return test_equal(res, 35)
}

</code></pre>
<h3 id="8.5">While control with labels</h3>
<p>We can use `break` and `continue` not only to nearest loop, but also to given labeled loop.</p>
<pre><code>test demo_while_control_with_labels {
    def a := while .foo (1) {
        eval while (1) {
            break .foo 32
        }
    }
    else 0
    
    def i := 0
    def b := while .foo (1) {
        eval if (i = 3) { break 43 }
        eval while (1) {
            i := i + 1
            continue .foo
        }
    }
    else 0

    return test_equal(a - b, -11)
}
</code></pre>
</main></div></body></html>
